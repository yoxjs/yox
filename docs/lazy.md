`lazy` 不是一个 `指令`，它的角色是辅助 `指令` 实现函数节流或别的自定义逻辑。

## 事件节流

有些 DOM 事件触发地非常频繁，比如 `scroll` 事件，通常我们并不需要如此高频率的触发，通过 `lazy` 设置一个调用间隔时间就能解决这个问题。

```html
<div on-scroll="scroll()" lazy="1000">
  balabala
</div>
```

它的逻辑是，当 `scroll` 事件触发后，不会立即调用 `scroll()`，而是等待 `1000` 毫秒，再调用 `scroll()`，并保持 `1000` 毫秒调用一次的频率。

## 多事件节流

当一个节点需要节流多个事件时，可以使用 `lazy-[type]` 语法，如下：

```html
<div
  on-mousedown="mousedown" on-mouseup="mouseup" on-mouseover="mouseover"
  lazy-mousedown="100" lazy-mouseup="200" lazy="300"
>
  xx
</div>
```

对于事件指令来说，优先读取跟自己事件名称匹配的 `lazy`，如果不存在，再读默认的 `lazy`。也就是说，`mouseover` 事件的调用频率是 `300` 毫秒一次。

## 过滤连续点击

提交表单时，服务端通常会要求前端不能连续提交多次。

> 作为常识，前端应该自觉加上此功能，而不是等着对方提醒。

常见的解决方案是，点击提交按钮时，禁用按钮，等到请求返回后，解禁按钮。

但你知道，每天都这么写，写了成百上千次后，你会忍不住怀疑人生，如此简单的功能不能简单一点么？

其实，`lazy` 很适合解决这个问题。

```html
<button on-click="submit()" lazy="1000">
  Submit
</button>
```

当点击按钮时，先立即调用一次 `submit()`，然后在 `1000` 毫秒内停止响应，这样便轻松地实现了这个功能。

你会发现，这个流程和 `事件节流` 中提到的不太一致，这里是 `先调用后等待`，`事件节流` 是 `先等待后调用`。

这是我们专门为过滤连续点击实现的特性，适用的事件包括 `click` 事件和 `tap` 事件。虽然浏览器并没有 `tap` 事件，这是我们为业务层预留的，也许你会想用，或者有第三方库帮你实现了。

需要注意的是，如果点击的按钮是表单控件元素，比如 `<button>`，默认会产生跳转行为。

我们可以在事件处理函数中阻止事件的默认行为，但如果有 `lazy` 加持的话，等待过程中触发的点击事件，并不会调用该函数，因此事件的默认行为也就无法阻止了。

## 双向绑定

对于双向绑定的输入框来说，有时候并不需要数据实时变化，比如输入框要求填入手机号，为此你写了一个表单验证函数，判断是否是合法的手机号。

当你输入 `1`，触发表单验证逻辑，提示 `手机号码格式错误`，你无视错误，继续输入 `2`，它又提示 `手机号码格式错误`...

事件节流明显不适合这个场景，我们转换一下思路，其实可以把监听的 `input` 事件改成 `change` 事件，当输入框失焦时，触发一次表单验证即可，如下：

```html
<div>
  <!--
    监听 change 事件
    因为只有一个 lazy，这里写 lazy 或 lazy-model 都可以
  -->
  <input type="text" model="content" lazy-model>
  <!-- 1 秒触发一次 input 事件 -->
  <input type="text" model="content" lazy="1000">
</div>
```

## 自定义指令

在自定义指令的 `bind` 钩子中读取 `lazy` 配置。

```js
{
  bind: function (node, directive, vnode) {
    // lazy 是个对象
    var lazy = vnode.lazy
  }
}
```

我们通过一个例子来看下 `lazy` 的数据格式：

```html
<div lazy lazy-a="100" lazy-b></div>
```

```js
{
  '': true,
  a: 100,
  b: true
}
```

至于你想用它做点什么，请随意。